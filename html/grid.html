<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grid API documentation</title>
<meta name="description" content="One-shot object detection require utilities to transform the input onto a grid to compare against the neural network output which also produces a grid." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grid</code></h1>
</header>
<section id="section-intro">
<p>One-shot object detection require utilities to transform the input onto a grid to compare against the neural network output which also produces a grid.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
One-shot object detection require utilities to transform the input onto a grid to compare against the neural network output which also produces a grid.
&#39;&#39;&#39;

import torch

def slice_center(bbox):
    &#39;&#39;&#39; Place the object only on the center location of the object (similar to YOLOv3). If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    cx = (bbox[0]+bbox[2]) // 2
    cy = (bbox[1]+bbox[3]) // 2
    return (cx, cy, cx+1, cy+1)

def slice_all(bbox):
    &#39;&#39;&#39; Choose all grid locations that contain the object, even if only one pixel. &#39;&#39;&#39;
    return (
        torch.floor(bbox[0]), torch.floor(bbox[1]),
        torch.ceil(bbox[2]), torch.ceil(bbox[3])
    )

def slice_all_center(bbox):
    &#39;&#39;&#39; Choose all grid locations where the center contains the object, as FCOS does, so that the bounding boxes offsets relative to the center are always positive. If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    return torch.round(bbox)

def slices(slicing, batch_bboxes, grid_size, img_size):
    &#39;&#39;&#39; Grid with true on the locations where the object is according to the slicing `criterium`. If you use 0-1 normalized bboxes, then give `img_size=(1,1)`. &#39;&#39;&#39;
    device = batch_bboxes[0].device
    scale = torch.tensor([grid_size[1]/img_size[1], grid_size[0]/img_size[0]]*2, device=device)
    to_slice = lambda s: (slice(int(s[1]), int(s[3])), slice(int(s[0]), int(s[2])))
    return [[to_slice(slicing(bbox*scale)) for bbox in bboxes]
        for bboxes in batch_bboxes]

def where(batch_slices, grid_size, device=None):
    &#39;&#39;&#39; Grid with 1 wherever the object is, 0 otherwise, according to the chosen slice strategy. &#39;&#39;&#39;
    n = len(batch_slices)
    grid = torch.zeros((n, *grid_size), dtype=torch.bool, device=device)
    for i, slices in enumerate(batch_slices):
        for yy, xx in slices:
            grid[i, yy, xx] = True
    return grid

def to_grid(batch_data, channels, batch_slices, grid_size, device=None):
    &#39;&#39;&#39; Maps the `batch_data` onto a grid of size `grid_size`, according to the `batch_slices`. &#39;&#39;&#39;
    n = len(batch_slices)
    grid = torch.zeros((n, channels, *grid_size), dtype=torch.float32, device=device)
    for i, (slices, data) in enumerate(zip(batch_slices, batch_data)):
        for (yy, xx), d in zip(slices, data):
            grid[i, :, yy, xx] = d[:, None, None]
    return grid

def select(where, grid, keep_batches):
    &#39;&#39;&#39; Select the grid components where `where` is true. If `keep_batches=True`, then the result will be a list of tensors. &#39;&#39;&#39;
    grid = grid.permute(0, 2, 3, 1)  # NCHW =&gt; NHWC
    if keep_batches:
        return [g[w, :] for w, g in zip(where, grid)]
    return grid[where, :]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="grid.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>where, grid, keep_batches)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the grid components where <code><a title="grid.where" href="#grid.where">where()</a></code> is true. If <code>keep_batches=True</code>, then the result will be a list of tensors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(where, grid, keep_batches):
    &#39;&#39;&#39; Select the grid components where `where` is true. If `keep_batches=True`, then the result will be a list of tensors. &#39;&#39;&#39;
    grid = grid.permute(0, 2, 3, 1)  # NCHW =&gt; NHWC
    if keep_batches:
        return [g[w, :] for w, g in zip(where, grid)]
    return grid[where, :]</code></pre>
</details>
</dd>
<dt id="grid.slice_all"><code class="name flex">
<span>def <span class="ident">slice_all</span></span>(<span>bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Choose all grid locations that contain the object, even if only one pixel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_all(bbox):
    &#39;&#39;&#39; Choose all grid locations that contain the object, even if only one pixel. &#39;&#39;&#39;
    return (
        torch.floor(bbox[0]), torch.floor(bbox[1]),
        torch.ceil(bbox[2]), torch.ceil(bbox[3])
    )</code></pre>
</details>
</dd>
<dt id="grid.slice_all_center"><code class="name flex">
<span>def <span class="ident">slice_all_center</span></span>(<span>bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Choose all grid locations where the center contains the object, as FCOS does, so that the bounding boxes offsets relative to the center are always positive. If the bounding boxes are normalized then you can use img_size=(1,1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_all_center(bbox):
    &#39;&#39;&#39; Choose all grid locations where the center contains the object, as FCOS does, so that the bounding boxes offsets relative to the center are always positive. If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    return torch.round(bbox)</code></pre>
</details>
</dd>
<dt id="grid.slice_center"><code class="name flex">
<span>def <span class="ident">slice_center</span></span>(<span>bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Place the object only on the center location of the object (similar to YOLOv3). If the bounding boxes are normalized then you can use img_size=(1,1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_center(bbox):
    &#39;&#39;&#39; Place the object only on the center location of the object (similar to YOLOv3). If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    cx = (bbox[0]+bbox[2]) // 2
    cy = (bbox[1]+bbox[3]) // 2
    return (cx, cy, cx+1, cy+1)</code></pre>
</details>
</dd>
<dt id="grid.slices"><code class="name flex">
<span>def <span class="ident">slices</span></span>(<span>slicing, batch_bboxes, grid_size, img_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Grid with true on the locations where the object is according to the slicing <code>criterium</code>. If you use 0-1 normalized bboxes, then give <code>img_size=(1,1)</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slices(slicing, batch_bboxes, grid_size, img_size):
    &#39;&#39;&#39; Grid with true on the locations where the object is according to the slicing `criterium`. If you use 0-1 normalized bboxes, then give `img_size=(1,1)`. &#39;&#39;&#39;
    device = batch_bboxes[0].device
    scale = torch.tensor([grid_size[1]/img_size[1], grid_size[0]/img_size[0]]*2, device=device)
    to_slice = lambda s: (slice(int(s[1]), int(s[3])), slice(int(s[0]), int(s[2])))
    return [[to_slice(slicing(bbox*scale)) for bbox in bboxes]
        for bboxes in batch_bboxes]</code></pre>
</details>
</dd>
<dt id="grid.to_grid"><code class="name flex">
<span>def <span class="ident">to_grid</span></span>(<span>batch_data, channels, batch_slices, grid_size, device=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Maps the <code>batch_data</code> onto a grid of size <code>grid_size</code>, according to the <code>batch_slices</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_grid(batch_data, channels, batch_slices, grid_size, device=None):
    &#39;&#39;&#39; Maps the `batch_data` onto a grid of size `grid_size`, according to the `batch_slices`. &#39;&#39;&#39;
    n = len(batch_slices)
    grid = torch.zeros((n, channels, *grid_size), dtype=torch.float32, device=device)
    for i, (slices, data) in enumerate(zip(batch_slices, batch_data)):
        for (yy, xx), d in zip(slices, data):
            grid[i, :, yy, xx] = d[:, None, None]
    return grid</code></pre>
</details>
</dd>
<dt id="grid.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>batch_slices, grid_size, device=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Grid with 1 wherever the object is, 0 otherwise, according to the chosen slice strategy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(batch_slices, grid_size, device=None):
    &#39;&#39;&#39; Grid with 1 wherever the object is, 0 otherwise, according to the chosen slice strategy. &#39;&#39;&#39;
    n = len(batch_slices)
    grid = torch.zeros((n, *grid_size), dtype=torch.bool, device=device)
    for i, slices in enumerate(batch_slices):
        for yy, xx in slices:
            grid[i, yy, xx] = True
    return grid</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="grid.select" href="#grid.select">select</a></code></li>
<li><code><a title="grid.slice_all" href="#grid.slice_all">slice_all</a></code></li>
<li><code><a title="grid.slice_all_center" href="#grid.slice_all_center">slice_all_center</a></code></li>
<li><code><a title="grid.slice_center" href="#grid.slice_center">slice_center</a></code></li>
<li><code><a title="grid.slices" href="#grid.slices">slices</a></code></li>
<li><code><a title="grid.to_grid" href="#grid.to_grid">to_grid</a></code></li>
<li><code><a title="grid.where" href="#grid.where">where</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>