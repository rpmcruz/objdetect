<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>grid API documentation</title>
<meta name="description" content="One-shot object detection require utilities to transform the input onto a grid to compare against the neural network output which also produces a grid." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>grid</code></h1>
</header>
<section id="section-intro">
<p>One-shot object detection require utilities to transform the input onto a grid to compare against the neural network output which also produces a grid.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
One-shot object detection require utilities to transform the input onto a grid to compare against the neural network output which also produces a grid.
&#39;&#39;&#39;

import torch

def slice_center(bbox):
    &#39;&#39;&#39; Place the object only on the center location of the object (similar to YOLOv3). If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    cx = (bbox[0]+bbox[2]) // 2
    cy = (bbox[1]+bbox[3]) // 2
    return (cx, cy, cx+1, cy+1)

def slice_all(bbox):
    &#39;&#39;&#39; Choose all grid locations that contain the object, even if only one pixel. &#39;&#39;&#39;
    return (
        torch.floor(bbox[0]), torch.floor(bbox[1]),
        torch.ceil(bbox[2]), torch.ceil(bbox[3])
    )

def slice_all_center(bbox):
    &#39;&#39;&#39; Choose all grid locations where the center contains the object, as FCOS does, so that the bounding boxes offsets relative to the center are always positive. If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    return torch.round(bbox)

def where(slicing, batch_bboxes, grid_size, img_size):
    &#39;&#39;&#39; Following the given `slicing` function strategy, returns two things: a boolean grid mask where objects are located, and a list of indices of which bounding box was used. The mask can be used with `mask_select()` to convert a grid to a list, and the indices can be used with `indices_select()` to convert a list to another list matching the elements selected from the grid. &#39;&#39;&#39;
    device = batch_bboxes[0].device
    scale = torch.tensor([grid_size[1]/img_size[1],
        grid_size[0]/img_size[0]]*2, device=device)
    n = len(batch_bboxes)
    mask = torch.zeros((n, *grid_size), dtype=torch.bool, device=device)
    indices = torch.zeros((n, *grid_size), dtype=torch.int64, device=device)
    for i, bboxes in enumerate(batch_bboxes):
        for j, bbox in enumerate(bboxes):
            s = slicing(bbox*scale)
            yy = slice(int(s[1]), int(s[3]))
            xx = slice(int(s[0]), int(s[2]))
            mask[i, yy, xx] = True
            indices[i, yy, xx] = j
    indices = [i[m] for i, m in zip(indices, mask)]
    return mask, indices

def mask_select(mask, grid, keep_batches=False):
    &#39;&#39;&#39; Select the grid components where `mask` is true. If `keep_batches=True`, then the result will be a list of tensors. &#39;&#39;&#39;
    grid = grid.permute(0, 2, 3, 1)  # NCHW =&gt; NHWC
    if keep_batches:
        return [g[m, :] for g, m in zip(grid, mask)]
    return grid[mask, :]

def indices_select(indices, data):
    &#39;&#39;&#39; Returns a tensor with the data in the same form as the indices. &#39;&#39;&#39;
    return torch.cat([d[i] for d, i in zip(data, indices)])

def to_grid(mask, indices, batch_data):
    &#39;&#39;&#39; Converts the given `batch_data` onto a grid, according to the `mask` and `indices` selected. Usually, you can avoid this function and work entirely in list space. &#39;&#39;&#39;
    device = mask.device
    channels = batch_data[0].shape[1]
    dtype = batch_data[0].dtype
    grid = torch.zeros((mask.shape[0], channels, *mask.shape[1:]), dtype=dtype, device=device)
    for g, m, d, i in zip(grid, mask, batch_data, indices):
        if len(i):
            g[:, m] = d[i].T
    return grid</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="grid.indices_select"><code class="name flex">
<span>def <span class="ident">indices_select</span></span>(<span>indices, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tensor with the data in the same form as the indices.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indices_select(indices, data):
    &#39;&#39;&#39; Returns a tensor with the data in the same form as the indices. &#39;&#39;&#39;
    return torch.cat([d[i] for d, i in zip(data, indices)])</code></pre>
</details>
</dd>
<dt id="grid.mask_select"><code class="name flex">
<span>def <span class="ident">mask_select</span></span>(<span>mask, grid, keep_batches=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Select the grid components where <code>mask</code> is true. If <code>keep_batches=True</code>, then the result will be a list of tensors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_select(mask, grid, keep_batches=False):
    &#39;&#39;&#39; Select the grid components where `mask` is true. If `keep_batches=True`, then the result will be a list of tensors. &#39;&#39;&#39;
    grid = grid.permute(0, 2, 3, 1)  # NCHW =&gt; NHWC
    if keep_batches:
        return [g[m, :] for g, m in zip(grid, mask)]
    return grid[mask, :]</code></pre>
</details>
</dd>
<dt id="grid.slice_all"><code class="name flex">
<span>def <span class="ident">slice_all</span></span>(<span>bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Choose all grid locations that contain the object, even if only one pixel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_all(bbox):
    &#39;&#39;&#39; Choose all grid locations that contain the object, even if only one pixel. &#39;&#39;&#39;
    return (
        torch.floor(bbox[0]), torch.floor(bbox[1]),
        torch.ceil(bbox[2]), torch.ceil(bbox[3])
    )</code></pre>
</details>
</dd>
<dt id="grid.slice_all_center"><code class="name flex">
<span>def <span class="ident">slice_all_center</span></span>(<span>bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Choose all grid locations where the center contains the object, as FCOS does, so that the bounding boxes offsets relative to the center are always positive. If the bounding boxes are normalized then you can use img_size=(1,1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_all_center(bbox):
    &#39;&#39;&#39; Choose all grid locations where the center contains the object, as FCOS does, so that the bounding boxes offsets relative to the center are always positive. If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    return torch.round(bbox)</code></pre>
</details>
</dd>
<dt id="grid.slice_center"><code class="name flex">
<span>def <span class="ident">slice_center</span></span>(<span>bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Place the object only on the center location of the object (similar to YOLOv3). If the bounding boxes are normalized then you can use img_size=(1,1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice_center(bbox):
    &#39;&#39;&#39; Place the object only on the center location of the object (similar to YOLOv3). If the bounding boxes are normalized then you can use img_size=(1,1). &#39;&#39;&#39;
    cx = (bbox[0]+bbox[2]) // 2
    cy = (bbox[1]+bbox[3]) // 2
    return (cx, cy, cx+1, cy+1)</code></pre>
</details>
</dd>
<dt id="grid.to_grid"><code class="name flex">
<span>def <span class="ident">to_grid</span></span>(<span>mask, indices, batch_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts the given <code>batch_data</code> onto a grid, according to the <code>mask</code> and <code>indices</code> selected. Usually, you can avoid this function and work entirely in list space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_grid(mask, indices, batch_data):
    &#39;&#39;&#39; Converts the given `batch_data` onto a grid, according to the `mask` and `indices` selected. Usually, you can avoid this function and work entirely in list space. &#39;&#39;&#39;
    device = mask.device
    channels = batch_data[0].shape[1]
    dtype = batch_data[0].dtype
    grid = torch.zeros((mask.shape[0], channels, *mask.shape[1:]), dtype=dtype, device=device)
    for g, m, d, i in zip(grid, mask, batch_data, indices):
        if len(i):
            g[:, m] = d[i].T
    return grid</code></pre>
</details>
</dd>
<dt id="grid.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>slicing, batch_bboxes, grid_size, img_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Following the given <code>slicing</code> function strategy, returns two things: a boolean grid mask where objects are located, and a list of indices of which bounding box was used. The mask can be used with <code><a title="grid.mask_select" href="#grid.mask_select">mask_select()</a></code> to convert a grid to a list, and the indices can be used with <code><a title="grid.indices_select" href="#grid.indices_select">indices_select()</a></code> to convert a list to another list matching the elements selected from the grid.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(slicing, batch_bboxes, grid_size, img_size):
    &#39;&#39;&#39; Following the given `slicing` function strategy, returns two things: a boolean grid mask where objects are located, and a list of indices of which bounding box was used. The mask can be used with `mask_select()` to convert a grid to a list, and the indices can be used with `indices_select()` to convert a list to another list matching the elements selected from the grid. &#39;&#39;&#39;
    device = batch_bboxes[0].device
    scale = torch.tensor([grid_size[1]/img_size[1],
        grid_size[0]/img_size[0]]*2, device=device)
    n = len(batch_bboxes)
    mask = torch.zeros((n, *grid_size), dtype=torch.bool, device=device)
    indices = torch.zeros((n, *grid_size), dtype=torch.int64, device=device)
    for i, bboxes in enumerate(batch_bboxes):
        for j, bbox in enumerate(bboxes):
            s = slicing(bbox*scale)
            yy = slice(int(s[1]), int(s[3]))
            xx = slice(int(s[0]), int(s[2]))
            mask[i, yy, xx] = True
            indices[i, yy, xx] = j
    indices = [i[m] for i, m in zip(indices, mask)]
    return mask, indices</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="grid.indices_select" href="#grid.indices_select">indices_select</a></code></li>
<li><code><a title="grid.mask_select" href="#grid.mask_select">mask_select</a></code></li>
<li><code><a title="grid.slice_all" href="#grid.slice_all">slice_all</a></code></li>
<li><code><a title="grid.slice_all_center" href="#grid.slice_all_center">slice_all_center</a></code></li>
<li><code><a title="grid.slice_center" href="#grid.slice_center">slice_center</a></code></li>
<li><code><a title="grid.to_grid" href="#grid.to_grid">to_grid</a></code></li>
<li><code><a title="grid.where" href="#grid.where">where</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>